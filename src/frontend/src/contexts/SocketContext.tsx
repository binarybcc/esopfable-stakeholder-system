import React, { createContext, useContext, useEffect, useState, ReactNode } from 'react';\nimport { io, Socket } from 'socket.io-client';\nimport { useAuth } from './AuthContext';\nimport toast from 'react-hot-toast';\n\ninterface SocketContextType {\n  socket: Socket | null;\n  isConnected: boolean;\n  emit: (event: string, data?: any) => void;\n  on: (event: string, callback: (data: any) => void) => void;\n  off: (event: string, callback?: (data: any) => void) => void;\n}\n\nconst SocketContext = createContext<SocketContextType | undefined>(undefined);\n\ninterface SocketProviderProps {\n  children: ReactNode;\n}\n\nexport const SocketProvider: React.FC<SocketProviderProps> = ({ children }) => {\n  const [socket, setSocket] = useState<Socket | null>(null);\n  const [isConnected, setIsConnected] = useState(false);\n  const { isAuthenticated, token, user } = useAuth();\n\n  useEffect(() => {\n    if (!isAuthenticated || !token) {\n      // Disconnect socket if not authenticated\n      if (socket) {\n        socket.disconnect();\n        setSocket(null);\n        setIsConnected(false);\n      }\n      return;\n    }\n\n    // Create socket connection\n    const newSocket = io(process.env.REACT_APP_API_URL || 'http://localhost:3001', {\n      auth: {\n        token,\n      },\n      transports: ['websocket', 'polling'],\n      timeout: 20000,\n      reconnection: true,\n      reconnectionAttempts: 5,\n      reconnectionDelay: 1000,\n      reconnectionDelayMax: 5000,\n    });\n\n    // Connection event handlers\n    newSocket.on('connect', () => {\n      console.log('Socket connected:', newSocket.id);\n      setIsConnected(true);\n      \n      // Join user's personal room for targeted notifications\n      if (user?.id) {\n        newSocket.emit('join-user-room', user.id);\n      }\n    });\n\n    newSocket.on('disconnect', (reason) => {\n      console.log('Socket disconnected:', reason);\n      setIsConnected(false);\n    });\n\n    newSocket.on('connect_error', (error) => {\n      console.error('Socket connection error:', error);\n      setIsConnected(false);\n    });\n\n    newSocket.on('reconnect', (attemptNumber) => {\n      console.log('Socket reconnected after', attemptNumber, 'attempts');\n      toast.success('Connection restored');\n    });\n\n    newSocket.on('reconnect_failed', () => {\n      console.error('Socket reconnection failed');\n      toast.error('Unable to reconnect. Please refresh the page.');\n    });\n\n    // Set up global event handlers\n    setupGlobalEventHandlers(newSocket);\n\n    setSocket(newSocket);\n\n    // Cleanup on unmount\n    return () => {\n      newSocket.disconnect();\n      setSocket(null);\n      setIsConnected(false);\n    };\n  }, [isAuthenticated, token, user?.id]);\n\n  const setupGlobalEventHandlers = (socket: Socket) => {\n    // Stakeholder events\n    socket.on('stakeholder:created', (data) => {\n      toast.success(`New stakeholder created: ${data.stakeholder.name}`);\n      // Trigger React Query cache invalidation\n      window.dispatchEvent(new CustomEvent('invalidate-stakeholders'));\n    });\n\n    socket.on('stakeholder:updated', (data) => {\n      toast(`Stakeholder updated: ${data.stakeholder.name}`, { icon: '🔄' });\n      window.dispatchEvent(new CustomEvent('invalidate-stakeholders'));\n    });\n\n    socket.on('stakeholder:deleted', (data) => {\n      toast.error('Stakeholder deleted');\n      window.dispatchEvent(new CustomEvent('invalidate-stakeholders'));\n    });\n\n    // Document events\n    socket.on('documents:uploaded', (data) => {\n      const count = data.documents.length;\n      toast.success(`${count} document${count > 1 ? 's' : ''} uploaded successfully`);\n      window.dispatchEvent(new CustomEvent('invalidate-documents'));\n    });\n\n    socket.on('document:updated', (data) => {\n      toast(`Document updated: ${data.document.title}`, { icon: '📄' });\n      window.dispatchEvent(new CustomEvent('invalidate-documents'));\n    });\n\n    socket.on('document:deleted', (data) => {\n      toast.error('Document deleted');\n      window.dispatchEvent(new CustomEvent('invalidate-documents'));\n    });\n\n    // Communication events\n    socket.on('communication:new', (data) => {\n      toast(`New ${data.communication.type}: ${data.communication.subject}`, { icon: '💬' });\n      window.dispatchEvent(new CustomEvent('invalidate-communications'));\n    });\n\n    // Task events\n    socket.on('task:created', (data) => {\n      toast.success(`New task assigned: ${data.task.title}`);\n      window.dispatchEvent(new CustomEvent('invalidate-tasks'));\n    });\n\n    socket.on('task:updated', (data) => {\n      const statusIcon = data.task.status === 'completed' ? '✅' : '📝';\n      toast(`Task updated: ${data.task.title}`, { icon: statusIcon });\n      window.dispatchEvent(new CustomEvent('invalidate-tasks'));\n    });\n\n    // Evidence events\n    socket.on('evidence:new', (data) => {\n      toast(`New evidence added: ${data.evidence.title}`, { icon: '🔍' });\n      window.dispatchEvent(new CustomEvent('invalidate-evidence'));\n    });\n\n    // Risk monitoring events\n    socket.on('risk:alert', (data) => {\n      toast.error(`Risk Alert: ${data.alert.message}`, {\n        duration: 8000,\n        icon: '⚠️',\n      });\n      window.dispatchEvent(new CustomEvent('risk-alert', { detail: data.alert }));\n    });\n\n    socket.on('risk:threat-detected', (data) => {\n      toast.error(`Threat Detected: ${data.threat.description}`, {\n        duration: 10000,\n        icon: '🚨',\n      });\n      window.dispatchEvent(new CustomEvent('threat-detected', { detail: data.threat }));\n    });\n\n    // PR Message events\n    socket.on('pr-message:approved', (data) => {\n      toast.success(`PR message approved: ${data.message.subject}`);\n      window.dispatchEvent(new CustomEvent('invalidate-pr-messages'));\n    });\n\n    socket.on('pr-message:rejected', (data) => {\n      toast.error(`PR message rejected: ${data.message.subject}`);\n      window.dispatchEvent(new CustomEvent('invalidate-pr-messages'));\n    });\n\n    // System events\n    socket.on('system:maintenance', (data) => {\n      toast(`System maintenance scheduled: ${data.message}`, {\n        icon: '🔧',\n        duration: 6000,\n      });\n    });\n\n    socket.on('system:alert', (data) => {\n      toast.error(`System Alert: ${data.message}`, {\n        duration: 8000,\n      });\n    });\n\n    // User-specific notifications\n    socket.on('notification:personal', (data) => {\n      toast(data.message, {\n        icon: data.icon || '📢',\n        duration: data.duration || 5000,\n      });\n    });\n  };\n\n  const emit = (event: string, data?: any) => {\n    if (socket && isConnected) {\n      socket.emit(event, data);\n    } else {\n      console.warn('Socket not connected. Cannot emit event:', event);\n    }\n  };\n\n  const on = (event: string, callback: (data: any) => void) => {\n    if (socket) {\n      socket.on(event, callback);\n    }\n  };\n\n  const off = (event: string, callback?: (data: any) => void) => {\n    if (socket) {\n      if (callback) {\n        socket.off(event, callback);\n      } else {\n        socket.off(event);\n      }\n    }\n  };\n\n  const contextValue: SocketContextType = {\n    socket,\n    isConnected,\n    emit,\n    on,\n    off,\n  };\n\n  return (\n    <SocketContext.Provider value={contextValue}>\n      {children}\n    </SocketContext.Provider>\n  );\n};\n\nexport const useSocket = (): SocketContextType => {\n  const context = useContext(SocketContext);\n  if (context === undefined) {\n    throw new Error('useSocket must be used within a SocketProvider');\n  }\n  return context;\n};\n\n// Custom hook for listening to specific socket events\nexport const useSocketEvent = (event: string, callback: (data: any) => void) => {\n  const { socket } = useSocket();\n\n  useEffect(() => {\n    if (socket) {\n      socket.on(event, callback);\n      return () => {\n        socket.off(event, callback);\n      };\n    }\n  }, [socket, event, callback]);\n};\n\n// Hook for real-time data updates\nexport const useRealTimeUpdates = (queryKey: string) => {\n  const { isConnected } = useSocket();\n\n  useEffect(() => {\n    const handleInvalidate = () => {\n      // This will be used by React Query to invalidate specific queries\n      window.dispatchEvent(new CustomEvent(`invalidate-${queryKey}`));\n    };\n\n    window.addEventListener(`invalidate-${queryKey}`, handleInvalidate);\n    \n    return () => {\n      window.removeEventListener(`invalidate-${queryKey}`, handleInvalidate);\n    };\n  }, [queryKey]);\n\n  return { isConnected };\n};"